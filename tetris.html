<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>俄羅斯方塊 | Arcade</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* --- 變數系統 --- */
        :root {
            --bg-color: #0d1117;
            --accent: #58a6ff;
            --text-main: #f0f6fc;
            --text-muted: #8b949e;
            --border: #30363d;
            --grid-bg: #161b22;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; user-select: none; }

        body {
            background-color: #000;
            color: var(--text-main);
            font-family: 'Segoe UI', monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
        }

        /* 遊戲主容器 */
        .game-container {
            display: flex;
            gap: 20px;
            align-items: flex-start;
            justify-content: center;
            /* 移除 scale 縮放，直接用大尺寸 */
        }

        canvas {
            background-color: var(--grid-bg);
            border: 2px solid var(--border);
            border-radius: 4px;
            box-shadow: 0 0 30px rgba(88, 166, 255, 0.15);
            display: block;
        }

        /* 側邊欄資訊 */
        .side-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
            width: 120px;
        }

        .panel-box {
            background: var(--bg-color);
            border: 2px solid var(--border);
            border-radius: 8px;
            padding: 15px 10px;
            text-align: center;
        }

        .panel-title {
            font-size: 0.9rem;
            color: var(--text-muted);
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .panel-value {
            font-size: 1.4rem;
            font-weight: bold;
            color: var(--accent);
        }

        .mini-canvas {
            background: transparent;
            margin: 0 auto;
            display: block;
        }

        /* 狀態覆蓋層 */
        #overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(13, 17, 23, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
            backdrop-filter: blur(5px);
        }

        #overlay h1 { font-size: 4rem; color: var(--accent); margin-bottom: 10px; text-shadow: 0 0 20px rgba(88,166,255,0.6); }
        #overlay p { font-size: 1.2rem; color: var(--text-main); margin-bottom: 40px; }
        
        .btn {
            background: var(--accent); color: #0d1117;
            border: none; padding: 15px 40px;
            border-radius: 5px; font-weight: bold; font-size: 1.5rem;
            cursor: pointer; transition: 0.2s;
        }
        .btn:hover { transform: scale(1.05); box-shadow: 0 0 20px var(--accent); }

        .controls-hint {
            margin-top: 50px;
            font-size: 1rem;
            color: var(--text-muted);
            text-align: left;
            line-height: 2;
            background: rgba(255,255,255,0.05);
            padding: 20px;
            border-radius: 10px;
        }
        .key {
            display: inline-block;
            background: #333;
            padding: 2px 8px;
            border-radius: 4px;
            border-bottom: 3px solid #111;
            font-family: monospace;
            color: #fff;
            margin: 0 4px;
            font-weight: bold;
        }

        /* 手機控制項 */
        #mobile-controls {
            display: none;
            width: 100%;
            max-width: 500px;
            margin-top: 20px;
            grid-template-columns: 1fr 1fr 1fr 1fr 1fr;
            grid-template-rows: 70px 70px;
            gap: 15px;
            padding: 0 20px;
        }
        .m-btn {
            background: rgba(255,255,255,0.1);
            border: 1px solid var(--border);
            border-radius: 50%;
            color: #fff;
            display: flex; justify-content: center; align-items: center;
            font-size: 1.5rem;
        }
        .m-btn:active { background: var(--accent); color: #000; }
        .m-btn-drop { grid-column: span 5; border-radius: 15px; height: 60px; background: rgba(88, 166, 255, 0.2); border-color: var(--accent); }

        @media (max-width: 768px) {
            .game-container { flex-direction: column; align-items: center; gap: 10px; }
            .side-panel { flex-direction: row; width: 100%; justify-content: center; gap: 10px; }
            .panel-box { width: 90px; padding: 5px; }
            .panel-title { font-size: 0.7rem; }
            .panel-value { font-size: 1.1rem; }
            /* 手機上自動縮放 Canvas 以適應螢幕 */
            canvas#tetrisCanvas { height: 60vh; width: auto; max-width: 100%; }
            #mobile-controls { display: grid; }
            .controls-hint { display: none; }
        }
    </style>
</head>
<body>

    <div class="game-container">
        <!-- 左側面板 -->
        <div class="side-panel">
            <div class="panel-box">
                <div class="panel-title">HOLD</div>
                <canvas id="holdCanvas" width="80" height="80" class="mini-canvas"></canvas>
            </div>
            <div class="panel-box">
                <div class="panel-title">LEVEL</div>
                <div class="panel-value" id="level">1</div>
            </div>
            <div class="panel-box">
                <div class="panel-title">LINES</div>
                <div class="panel-value" id="lines">0</div>
            </div>
        </div>

        <!-- 主畫布 (尺寸加大到 320x640) -->
        <canvas id="tetrisCanvas" width="320" height="640"></canvas>

        <!-- 右側面板 -->
        <div class="side-panel">
            <div class="panel-box">
                <div class="panel-title">NEXT</div>
                <canvas id="nextCanvas" width="80" height="80" class="mini-canvas"></canvas>
            </div>
            <div class="panel-box">
                <div class="panel-title">SCORE</div>
                <div class="panel-value" id="score">0</div>
            </div>
            <div class="panel-box" style="border-color: gold;">
                <div class="panel-title" style="color: gold;">HIGH</div>
                <div class="panel-value" id="highScore" style="color: gold;">0</div>
            </div>
        </div>
    </div>

    <!-- 手機按鈕 -->
    <div id="mobile-controls">
        <div class="m-btn" ontouchstart="handleMobileInput('HOLD', event)"><i class="fa-solid fa-right-left"></i></div>
        <div class="m-btn" ontouchstart="handleMobileInput('LEFT', event)"><i class="fa-solid fa-arrow-left"></i></div>
        <div class="m-btn" ontouchstart="handleMobileInput('DOWN', event)"><i class="fa-solid fa-arrow-down"></i></div>
        <div class="m-btn" ontouchstart="handleMobileInput('RIGHT', event)"><i class="fa-solid fa-arrow-right"></i></div>
        <div class="m-btn" ontouchstart="handleMobileInput('ROTATE', event)"><i class="fa-solid fa-rotate-right"></i></div>
        <div class="m-btn m-btn-drop" ontouchstart="handleMobileInput('DROP', event)">HARD DROP</div>
    </div>

    <!-- 覆蓋層 -->
    <div id="overlay">
        <h1>TETRIS</h1>
        <p>Ready to Battle?</p>
        <button class="btn" onclick="startGame()">Start Game</button>
        
        <div class="controls-hint">
            <div><span class="key">←</span> <span class="key">→</span> 移動</div>
            <div><span class="key">↑</span> 順時針轉</div>
            <div><span class="key">Z</span> 逆時針轉</div>
            <div><span class="key">↓</span> 軟降</div>
            <div><span class="key">Space</span> 硬降 (Hard Drop)</div>
            <div><span class="key">Shift</span> 暫存 (Hold)</div>
        </div>
    </div>

    <script>
        (function() {
            const canvas = document.getElementById('tetrisCanvas');
            const ctx = canvas.getContext('2d');
            const nextCanvas = document.getElementById('nextCanvas');
            const nextCtx = nextCanvas.getContext('2d');
            const holdCanvas = document.getElementById('holdCanvas');
            const holdCtx = holdCanvas.getContext('2d');

            const ROWS = 20;
            const COLS = 10;
            const BLOCK_SIZE = 32; // [調整] 方塊加大到 32px

            // --- 方塊定義 (SRS) ---
            const I = [
                [[0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0], [0, 0, 0, 0]],
                [[0, 0, 1, 0], [0, 0, 1, 0], [0, 0, 1, 0], [0, 0, 1, 0]],
                [[0, 0, 0, 0], [0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0]],
                [[0, 1, 0, 0], [0, 1, 0, 0], [0, 1, 0, 0], [0, 1, 0, 0]]
            ];
            const J = [
                [[1, 0, 0], [1, 1, 1], [0, 0, 0]],
                [[0, 1, 1], [0, 1, 0], [0, 1, 0]],
                [[0, 0, 0], [1, 1, 1], [0, 0, 1]],
                [[0, 1, 0], [0, 1, 0], [1, 1, 0]]
            ];
            const L = [
                [[0, 0, 1], [1, 1, 1], [0, 0, 0]],
                [[0, 1, 0], [0, 1, 0], [0, 1, 1]],
                [[0, 0, 0], [1, 1, 1], [1, 0, 0]],
                [[1, 1, 0], [0, 1, 0], [0, 1, 0]]
            ];
            const O = [
                [[0, 0, 0, 0], [0, 1, 1, 0], [0, 1, 1, 0], [0, 0, 0, 0]],
                [[0, 0, 0, 0], [0, 1, 1, 0], [0, 1, 1, 0], [0, 0, 0, 0]],
                [[0, 0, 0, 0], [0, 1, 1, 0], [0, 1, 1, 0], [0, 0, 0, 0]],
                [[0, 0, 0, 0], [0, 1, 1, 0], [0, 1, 1, 0], [0, 0, 0, 0]]
            ];
            const S = [
                [[0, 1, 1], [1, 1, 0], [0, 0, 0]],
                [[0, 1, 0], [0, 1, 1], [0, 0, 1]],
                [[0, 0, 0], [0, 1, 1], [1, 1, 0]],
                [[1, 0, 0], [1, 1, 0], [0, 1, 0]]
            ];
            const T = [
                [[0, 1, 0], [1, 1, 1], [0, 0, 0]],
                [[0, 1, 0], [0, 1, 1], [0, 1, 0]],
                [[0, 0, 0], [1, 1, 1], [0, 1, 0]],
                [[0, 1, 0], [1, 1, 0], [0, 1, 0]]
            ];
            const Z = [
                [[1, 1, 0], [0, 1, 1], [0, 0, 0]],
                [[0, 0, 1], [0, 1, 1], [0, 1, 0]],
                [[0, 0, 0], [1, 1, 0], [0, 1, 1]],
                [[0, 1, 0], [1, 1, 0], [1, 0, 0]]
            ];

            const PIECES = [
                [Z, "#ef4444"], [S, "#22c55e"], [T, "#a855f7"], 
                [O, "#fbbf24"], [L, "#f97316"], [I, "#06b6d4"], [J, "#3b82f6"]
            ];

            let board = [];
            let score = 0;
            let lines = 0;
            let level = 1;
            let highScore = localStorage.getItem('tetrisHighScore') || 0;
            let dropStart = Date.now();
            let gameOver = false;
            let isPaused = false;
            let animationFrame;

            let p;
            let nextP;
            let holdP = null;
            let canHold = true;

            // [新增] 鎖定延遲相關變數
            const LOCK_DELAY = 500; // 0.5秒
            let lockStart = 0;
            let activeLock = false;

            document.getElementById('highScore').innerText = highScore;

            function createBoard() {
                for(let r = 0; r < ROWS; r++){
                    board[r] = [];
                    for(let c = 0; c < COLS; c++){
                        board[r][c] = "VACANT";
                    }
                }
            }

            function drawSquare(x, y, color, context = ctx, blockSize = BLOCK_SIZE) {
                context.fillStyle = color;
                context.fillRect(x * blockSize, y * blockSize, blockSize, blockSize);
                context.strokeStyle = "#161b22";
                context.strokeRect(x * blockSize, y * blockSize, blockSize, blockSize);
            }

            // [調整] 繪製背景格線
            function drawBoard() {
                for(let r = 0; r < ROWS; r++){
                    for(let c = 0; c < COLS; c++){
                        if (board[r][c] === "VACANT") {
                            // 繪製虛線或淡色框線
                            ctx.strokeStyle = "rgba(255, 255, 255, 0.05)";
                            ctx.strokeRect(c * BLOCK_SIZE, r * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                        } else {
                            drawSquare(c, r, board[r][c]);
                        }
                    }
                }
            }

            class Piece {
                constructor(tetromino, color) {
                    this.tetromino = tetromino;
                    this.color = color;
                    this.tetrominoN = 0;
                    this.activeTetromino = this.tetromino[this.tetrominoN];
                    this.x = 3;
                    this.y = -2;
                }

                draw() {
                    // Ghost
                    let ghostY = this.y;
                    while(!this.collision(0, 1, this.activeTetromino, ghostY)) {
                        ghostY++;
                    }
                    for(let r = 0; r < this.activeTetromino.length; r++){
                        for(let c = 0; c < this.activeTetromino.length; c++){
                            if(this.activeTetromino[r][c]){
                                if (ghostY + r >= 0) {
                                    ctx.fillStyle = "rgba(255, 255, 255, 0.1)";
                                    ctx.fillRect((this.x + c) * BLOCK_SIZE, (ghostY + r) * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                                    ctx.strokeStyle = "rgba(255, 255, 255, 0.3)";
                                    ctx.strokeRect((this.x + c) * BLOCK_SIZE, (ghostY + r) * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                                }
                            }
                        }
                    }
                    this.fill(this.color);
                }

                fill(color) {
                    for(let r = 0; r < this.activeTetromino.length; r++){
                        for(let c = 0; c < this.activeTetromino.length; c++){
                            if(this.activeTetromino[r][c]){
                                if (this.y + r >= 0) {
                                    drawSquare(this.x + c, this.y + r, color);
                                }
                            }
                        }
                    }
                }

                moveDown() {
                    if(!this.collision(0, 1, this.activeTetromino)){
                        this.y++;
                    } 
                    // 如果不能移動，這裡不做任何事，交給 gameLoop 的 Lock Delay 判斷
                }

                moveRight() {
                    if(!this.collision(1, 0, this.activeTetromino)){
                        this.x++;
                        this.resetLockTimer();
                    }
                }

                moveLeft() {
                    if(!this.collision(-1, 0, this.activeTetromino)){
                        this.x--;
                        this.resetLockTimer();
                    }
                }

                rotate(dir) {
                    let nextPatternN = (this.tetrominoN + dir + this.tetromino.length) % this.tetromino.length;
                    let nextPattern = this.tetromino[nextPatternN];
                    let kick = 0;
                    
                    if(this.collision(0, 0, nextPattern)){
                        if(this.x > COLS/2) kick = -1; else kick = 1;
                    }
                    
                    if(!this.collision(kick, 0, nextPattern)){
                        this.x += kick;
                        this.tetrominoN = nextPatternN;
                        this.activeTetromino = this.tetromino[this.tetrominoN];
                        this.resetLockTimer();
                    }
                }

                drop() {
                    // Hard Drop 忽略 Lock Delay，直接落地
                    while(!this.collision(0, 1, this.activeTetromino)){
                        this.y++;
                        score += 2;
                    }
                    this.lock();
                }

                // [新增] 當有操作成功時，如果處於接觸地板狀態，重置鎖定計時器
                resetLockTimer() {
                    if (this.collision(0, 1, this.activeTetromino)) {
                        lockStart = Date.now();
                        // 這裡可以加入重置次數限制防止無限拖延 (Infinite Spin)，目前先保留無限
                    } else {
                        // 如果移動後懸空了，取消鎖定狀態
                        activeLock = false;
                    }
                }

                lock() {
                    for(let r = 0; r < this.activeTetromino.length; r++){
                        for(let c = 0; c < this.activeTetromino.length; c++){
                            if(!this.activeTetromino[r][c]) continue;
                            if(this.y + r < 0){
                                handleGameOver();
                                break;
                            }
                            board[this.y + r][this.x + c] = this.color;
                        }
                    }
                    // 消行邏輯
                    for(let r = 0; r < ROWS; r++){
                        let isRowFull = true;
                        for(let c = 0; c < COLS; c++){
                            isRowFull = isRowFull && (board[r][c] != "VACANT");
                        }
                        if(isRowFull){
                            for(let y = r; y > 1; y--){
                                for(let c = 0; c < COLS; c++){
                                    board[y][c] = board[y-1][c];
                                }
                            }
                            for(let c = 0; c < COLS; c++){
                                board[0][c] = "VACANT";
                            }
                            score += 100 * level;
                            lines++;
                            if (lines % 15 === 0) {
                                level++;
                                document.getElementById('level').innerText = level;
                            }
                        }
                    }
                    
                    // 重置狀態
                    activeLock = false;
                    updateUI();
                    
                    // 生成下一塊
                    if (!gameOver) {
                        p = nextP;
                        nextP = randomPiece();
                        drawNextPiece();
                        canHold = true;
                        if (p.collision(0, 0, p.activeTetromino)) handleGameOver();
                    }
                }

                collision(x, y, piece, overrideY = null) {
                    let testY = (overrideY !== null) ? overrideY : this.y;
                    for(let r = 0; r < piece.length; r++){
                        for(let c = 0; c < piece.length; c++){
                            if(!piece[r][c]) continue;
                            let newX = this.x + c + x;
                            let newY = testY + r + y;
                            if(newX < 0 || newX >= COLS || newY >= ROWS) return true;
                            if(newY < 0) continue;
                            if(board[newY][newX] != "VACANT") return true;
                        }
                    }
                    return false;
                }
            }

            function randomPiece(){
                let r = Math.floor(Math.random() * PIECES.length);
                return new Piece(PIECES[r][0], PIECES[r][1]);
            }

            function drawMiniBoard(context, piece) {
                context.clearRect(0, 0, 80, 80);
                if (!piece) return;
                const size = 20; 
                const offset = (4 - piece.activeTetromino.length) * size / 2;
                for(let r = 0; r < piece.activeTetromino.length; r++){
                    for(let c = 0; c < piece.activeTetromino.length; c++){
                        if(piece.activeTetromino[r][c]){
                            context.fillStyle = piece.color;
                            context.fillRect(c * size + offset, r * size + offset, size, size);
                            context.strokeStyle = "#161b22";
                            context.strokeRect(c * size + offset, r * size + offset, size, size);
                        }
                    }
                }
            }

            function drawNextPiece() { drawMiniBoard(nextCtx, nextP); }
            function drawHoldPiece() { drawMiniBoard(holdCtx, holdP); }

            function hold() {
                if (!canHold) return;
                if (holdP === null) {
                    holdP = p;
                    holdP.tetrominoN = 0;
                    holdP.activeTetromino = holdP.tetromino[0];
                    p = nextP;
                    nextP = randomPiece();
                    drawNextPiece();
                } else {
                    let temp = p;
                    p = holdP;
                    holdP = temp;
                    p.x = 3; p.y = -2; p.tetrominoN = 0;
                    p.activeTetromino = p.tetromino[0];
                    holdP.tetrominoN = 0;
                    holdP.activeTetromino = holdP.tetromino[0];
                }
                // 切換後重置鎖定狀態
                activeLock = false;
                drawHoldPiece();
                canHold = false;
            }

            function updateUI() {
                document.getElementById('score').innerText = score;
                document.getElementById('lines').innerText = lines;
                document.getElementById('level').innerText = level;
                if (score > highScore) {
                    highScore = score;
                    localStorage.setItem('tetrisHighScore', highScore);
                    document.getElementById('highScore').innerText = highScore;
                }
            }

            function handleGameOver() {
                gameOver = true;
                document.getElementById('overlay').style.display = 'flex';
                document.querySelector('#overlay h1').innerText = "GAME OVER";
                document.querySelector('#overlay p').innerText = `Score: ${score} | Level: ${level}`;
                document.querySelector('.btn').innerText = "Try Again";
            }

            function gameLoop(){
                if (isPaused || gameOver) return;
                let now = Date.now();
                let delta = now - dropStart;
                let speed = Math.max(100, 1000 - (level - 1) * 100);

                // 重力邏輯
                if(delta > speed){
                    p.moveDown();
                    dropStart = Date.now();
                }

                // 繪圖
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawBoard();
                p.draw();

                // [新增] 鎖定延遲檢測
                // 檢查是否觸底
                if (p.collision(0, 1, p.activeTetromino)) {
                    if (!activeLock) {
                        // 剛觸底，開始計時
                        activeLock = true;
                        lockStart = Date.now();
                    } else {
                        // 已經在觸底狀態，檢查時間
                        if (Date.now() - lockStart > LOCK_DELAY) {
                            p.lock(); // 時間到，鎖定
                        }
                    }
                } else {
                    // 如果沒有觸底 (例如方塊被移動出去了)，重置狀態
                    activeLock = false;
                }

                animationFrame = requestAnimationFrame(gameLoop);
            }

            function startGame() {
                createBoard();
                score = 0; lines = 0; level = 1;
                gameOver = false; isPaused = false; canHold = true; holdP = null;
                activeLock = false; // 重置鎖定狀態
                
                holdCtx.clearRect(0, 0, 80, 80);
                
                p = randomPiece();
                nextP = randomPiece();
                drawNextPiece();
                updateUI();
                
                document.getElementById('overlay').style.display = 'none';
                if (animationFrame) cancelAnimationFrame(animationFrame);
                dropStart = Date.now();
                gameLoop();
            }

            document.addEventListener("keydown", (e) => {
                if (gameOver) return;
                if (e.key === 'p' || e.key === 'P') { /* Paused Logic if needed */ }
                if (isPaused) return;
                if(e.keyCode == 37) p.moveLeft();
                else if(e.keyCode == 38) p.rotate(1);
                else if(e.keyCode == 39) p.moveRight();
                else if(e.keyCode == 40) p.moveDown();
                else if(e.keyCode == 32) p.drop();
                else if(e.keyCode == 90) p.rotate(-1);
                else if(e.keyCode == 16) hold();
            });

            window.addEventListener("keydown", function(e) {
                if(["Space","ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].indexOf(e.code) > -1) {
                    e.preventDefault();
                }
            }, false);

            function handleMobileInput(action, e) {
                if (e) e.preventDefault();
                if (gameOver || isPaused) return;
                switch(action) {
                    case 'LEFT': p.moveLeft(); break;
                    case 'RIGHT': p.moveRight(); break;
                    case 'DOWN': p.moveDown(); break;
                    case 'ROTATE': p.rotate(1); break;
                    case 'DROP': p.drop(); break;
                    case 'HOLD': hold(); break;
                }
            }

            createBoard();
            drawBoard();

            window.startGame = startGame;
            window.handleMobileInput = handleMobileInput;
        })();
    </script>
</body>
</html>